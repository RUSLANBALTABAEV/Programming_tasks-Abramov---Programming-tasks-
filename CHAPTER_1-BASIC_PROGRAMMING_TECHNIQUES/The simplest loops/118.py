"""
ГЛАВА 1
ОСНОВНЫЕ ПРИЁМЫ ПРОГРАММИРОВАНИЯ
4. Простейшие циклы


118. Вычислить 1 - 1 / 2 + 1 / 3 - ... + 1 / 9999 - 1 / 10000 следующими четырьмя способами:
а) последовательно слева направо;
б) последовательно слева направо вычисляются 1 + 1 / 3 + 1 / 9999 и 1 / 2 + 1 / 3 + ... + 1 / 10000, затем второе значение вычитается из первого;
в) последовательно справа налево;
г) последовательно справа налево вычисляются суммы,
выписанные в б), затем - вычитание.
Почему при вычислениях на вычислительной машине каждым
из способов получаются разные результаты?
"""


def main():
    print("Вычисление суммы 1 - 1/2 + 1/3 - ... + 1/9999 - 1/10000\n")
    
    # Способ а) последовательно слева направо
    print("а) Последовательно слева направо:")
    sum_a = 0.0
    for i in range(1, 10001):
        if i % 2 == 1:  # нечетные i: 1, 3, 5, ... 9999
            sum_a += 1 / i
        else:  # четные i: 2, 4, 6, ... 10000
            sum_a -= 1 / i
    print(f"   Результат: {sum_a}")
    
    # Способ б) вычисление двух сумм слева направо и вычитание
    print("\nб) Две суммы слева направо, затем вычитание:")
    sum_positive = 0.0  # сумма положительных слагаемых: 1 + 1/3 + 1/5 + ... + 1/9999
    sum_negative = 0.0  # сумма (абсолютных значений) отрицательных: 1/2 + 1/4 + ... + 1/10000
    
    # Сумма положительных (нечетные знаменатели)
    for i in range(1, 10001, 2):
        sum_positive += 1 / i
    
    # Сумма отрицательных (четные знаменатели)
    for i in range(2, 10001, 2):
        sum_negative += 1 / i
    
    sum_b = sum_positive - sum_negative
    print(f"   Сумма положительных: {sum_positive}")
    print(f"   Сумма отрицательных: {sum_negative}")
    print(f"   Результат: {sum_b}")
    
    # Способ в) последовательно справа налево
    print("\nв) Последовательно справа налево:")
    sum_c = 0.0
    # Идем от последнего члена к первому
    for i in range(10000, 0, -1):
        if i % 2 == 1:  # нечетные i
            sum_c += 1 / i
        else:  # четные i
            sum_c -= 1 / i
    print(f"   Результат: {sum_c}")
    
    # Способ г) вычисление двух сумм справа налево и вычитание
    print("\nг) Две суммы справа налево, затем вычитание:")
    sum_positive_rev = 0.0
    sum_negative_rev = 0.0
    
    # Сумма положительных справа налево (от 1/9999 до 1)
    for i in range(9999, 0, -2):
        sum_positive_rev += 1 / i
    
    # Сумма отрицательных справа налево (от 1/10000 до 1/2)
    for i in range(10000, 1, -2):
        sum_negative_rev += 1 / i
    
    sum_d = sum_positive_rev - sum_negative_rev
    print(f"   Сумма положительных (справа налево): {sum_positive_rev}")
    print(f"   Сумма отрицательных (справа налево): {sum_negative_rev}")
    print(f"   Результат: {sum_d}")
    
    # Сравнение результатов
    print("\n" + "="*60)
    print("Сравнение результатов:")
    print(f"а) {sum_a}")
    print(f"б) {sum_b}")
    print(f"в) {sum_c}")
    print(f"г) {sum_d}")
    
    # Разности между результатами
    print("\nРазности между способами:")
    print(f"|а - б| = {abs(sum_a - sum_b)}")
    print(f"|а - в| = {abs(sum_a - sum_c)}")
    print(f"|а - г| = {abs(sum_a - sum_d)}")
    print(f"|б - в| = {abs(sum_b - sum_c)}")
    print(f"|б - г| = {abs(sum_b - sum_d)}")
    print(f"|в - г| = {abs(sum_c - sum_d)}")
    
    # Объяснение
    print("\n" + "="*60)
    print("Почему получаются разные результаты?")
    print("""
    При вычислениях на вычислительной машине каждый из способов дает 
    немного разные результаты из-за погрешностей округления при работе 
    с числами с плавающей точкой.
    
    Основные причины:
    1. Числа с плавающей точкой имеют ограниченную точность.
    2. Операции сложения и вычитания не являются ассоциативными 
       из-за округления промежуточных результатов.
    3. При сложении чисел сильно различающихся по величине 
       младшие разряды меньших чисел теряются.
    4. Порядок выполнения операций влияет на накопление ошибки округления.
    
    В данном случае:
    - В способе (а) мы попеременно прибавляем и вычитаем, что может 
      приводить к потере точности из-за вычитания близких по величине чисел.
    - В способе (б) мы сначала суммируем все положительные, затем все 
      отрицательные, и только потом вычитаем - это уменьшает потерю точности.
    - В способах (в) и (г) порядок слагаемых обратный, что также меняет 
      накопление ошибки округления.
    
    Результаты отличаются незначительно, но эта разница демонстрирует
    важность учета погрешностей при численных вычислениях.
    """)


if __name__ == "__main__":
    main()
    input("\nНажмите Enter, чтобы завершить программу.")
