"""
ГЛАВА 1
ОСНОВНЫЕ ПРИЁМЫ ПРОГРАММИРОВАНИЯ
7. Сочетания цикла и разветвления

215. Даны натуральное n, действительные числа a₁, ..., aₙ.
В последовательности a₁, ..., aₙ определить число соседств:
а) двух положительных чисел;
б) двух чисел разного знака;
в) двух чисел одного знака, причем модуль первого числа должен быть больше модуля второго числа.
"""


def count_adjacent_pairs(n, a):
    """
    Вычисляет количество соседств в последовательности.
    Возвращает три значения:
    - count_a: число пар соседних положительных чисел
    - count_b: число пар соседних чисел разного знака
    - count_c: число пар соседних чисел одного знака с |первого| > |второго|
    """
    count_a = 0  # два положительных
    count_b = 0  # разного знака
    count_c = 0  # одного знака, |первого| > |второго|
    
    # Проходим по всем соседним парам (a[i], a[i+1]) для i = 0..n-2
    for i in range(n - 1):
        first = a[i]
        second = a[i + 1]
        
        # а) два положительных числа
        if first > 0 and second > 0:
            count_a += 1
        
        # б) числа разного знака (исключаем нули)
        if (first > 0 and second < 0) or (first < 0 and second > 0):
            count_b += 1
        
        # в) одного знака и |первого| > |второго|
        # Проверяем, что оба числа одного знака и не равны 0
        if (first > 0 and second > 0) or (first < 0 and second < 0):
            if abs(first) > abs(second):
                count_c += 1
    
    return count_a, count_b, count_c


def count_adjacent_pairs_detailed(n, a):
    """
    Подробный анализ с выводом для каждой пары.
    Возвращает детальное описание и результаты подсчета.
    """
    steps = []
    steps.append("ПОДРОБНЫЙ АНАЛИЗ ПОСЛЕДОВАТЕЛЬНОСТИ")
    steps.append("=" * 85)
    steps.append(f"Последовательность: {a}")
    steps.append(f"Длина: n = {n}")
    steps.append("")
    steps.append("Анализ всех соседних пар (aᵢ, aᵢ₊₁):")
    steps.append(" i  aᵢ       aᵢ₊₁      Положит. пары?  Разные знаки?  Один знак, |aᵢ|>|aᵢ₊₁|?")
    steps.append("-" * 85)
    
    count_a = 0
    count_b = 0
    count_c = 0
    
    for i in range(n - 1):
        first = a[i]
        second = a[i + 1]
        
        # Определяем условия
        cond_a = "ДА" if (first > 0 and second > 0) else "нет"
        cond_b = "ДА" if ((first > 0 and second < 0) or (first < 0 and second > 0)) else "нет"
        
        # Для условия в)
        cond_c = "нет"
        if (first > 0 and second > 0) or (first < 0 and second < 0):
            if abs(first) > abs(second):
                cond_c = "ДА"
        
        # Считаем
        if cond_a == "ДА":
            count_a += 1
        if cond_b == "ДА":
            count_b += 1
        if cond_c == "ДА":
            count_c += 1
        
        steps.append(f"{i+1:2}  {first:7.3f}   {second:7.3f}   {cond_a:>15}   {cond_b:>12}   {cond_c:>20}")
    
    steps.append("-" * 85)
    steps.append(f"ИТОГО: {count_a:>28} {count_b:>12} {count_c:>20}")
    steps.append("=" * 85)
    
    detailed_explanation = "\n".join(steps)
    return detailed_explanation, count_a, count_b, count_c


def main():
    """
    Основная функция программы с выбором режима работы.
    """
    print("Программа анализа соседних пар в последовательности")
    print("=" * 70)
    print("Определяет число соседств:")
    print("  а) двух положительных чисел")
    print("  б) двух чисел разного знака")
    print("  в) двух чисел одного знака, причем |первого| > |второго|")
    print("=" * 70)
    
    choice = input("Выберите режим:\n1 - Использовать примеры\n2 - Ввести свои данные\nВведите 1 или 2: ")
    
    if choice == '1':
        # Примеры для демонстрации
        examples = [
            ("Пример 1", 8, [1.5, -2.3, 4.7, 0.8, -3.2, 2.1, -1.5, 0.5]),
            ("Пример 2 (все положительные)", 6, [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]),
            ("Пример 3 (чередование знаков)", 7, [1.0, -1.0, 2.0, -2.0, 3.0, -3.0, 4.0]),
            ("Пример 4 (с нулями)", 7, [0.0, 1.0, -1.0, 0.0, 2.0, -2.0, 0.0]),
            ("Пример 5 (для условия в)", 6, [5.0, 3.0, -4.0, -2.0, 1.0, 2.0]),
        ]
        
        for title, n, a in examples:
            print(f"\n{title}:")
            print(f"n = {n}, a = {a}")
            
            count_a, count_b, count_c = count_adjacent_pairs(n, a)
            
            print(f"Результаты:")
            print(f"  а) Два положительных числа: {count_a}")
            print(f"  б) Два числа разного знака: {count_b}")
            print(f"  в) Один знак, |первого| > |второго|: {count_c}")
            
            # Для первого примера предлагаем показать детали
            if title == "Пример 1":
                detailed_choice = input("\nПоказать подробный анализ для этого примера? (да/нет): ")
                if detailed_choice.lower() in ['да', 'д', 'yes', 'y']:
                    explanation, ca, cb, cc = count_adjacent_pairs_detailed(n, a)
                    print("\n" + explanation)
            
            print("-" * 60)
    
    elif choice == '2':
        # Ввод данных от пользователя
        try:
            n = int(input("\nВведите натуральное число n: "))
            if n <= 0:
                print("Ошибка: n должно быть натуральным числом!")
                return
            if n < 2:
                print("Для анализа соседств нужно как минимум 2 элемента!")
                return
            
            a = []
            for i in range(n):
                value = float(input(f"Введите a_{i+1}: "))
                a.append(value)
            
            print(f"\nВведена последовательность: a = {a}")
            
            # Вычисление результатов
            count_a, count_b, count_c = count_adjacent_pairs(n, a)
            
            print(f"\nРезультаты:")
            print(f"  а) Два положительных числа: {count_a}")
            print(f"  б) Два числа разного знака: {count_b}")
            print(f"  в) Один знак, |первого| > |второго|: {count_c}")
            
            # Предложение показать подробный анализ
            if n <= 20:  # Ограничим, чтобы не выводить огромные таблицы
                detailed_choice = input("\nПоказать подробный анализ? (да/нет): ")
                if detailed_choice.lower() in ['да', 'д', 'yes', 'y']:
                    explanation, ca, cb, cc = count_adjacent_pairs_detailed(n, a)
                    print("\n" + explanation)
            else:
                print(f"\nПримечание: подробный анализ доступен только для n ≤ 20.")
                print(f"Ваше n = {n} > 20, поэтому подробный анализ не отображается.")
        
        except ValueError:
            print("Ошибка ввода! Убедитесь, что вводите числа в правильном формате.")
            return
    
    else:
        print("Неверный выбор. Программа завершена.")
        return
    
    # Объяснение алгоритма
    print("\n" + "=" * 70)
    print("ОБЪЯСНЕНИЕ АЛГОРИТМА:")
    print("=" * 70)
    print("Для каждой пары соседних элементов (aᵢ, aᵢ₊₁), i = 1..n-1:")
    print("")
    print("а) Два положительных числа:")
    print("   Условие: aᵢ > 0 И aᵢ₊₁ > 0")
    print("   Примечание: 0 не считается положительным числом.")
    print("")
    print("б) Два числа разного знака:")
    print("   Условие: (aᵢ > 0 И aᵢ₊₁ < 0) ИЛИ (aᵢ < 0 И aᵢ₊₁ > 0)")
    print("   Примечание: если одно из чисел равно 0, пара не считается.")
    print("")
    print("в) Два числа одного знака, причем |aᵢ| > |aᵢ₊₁|:")
    print("   Условие: (aᵢ > 0 И aᵢ₊₁ > 0 И |aᵢ| > |aᵢ₊₁|) ИЛИ")
    print("            (aᵢ < 0 И aᵢ₊₁ < 0 И |aᵢ| > |aᵢ₊₁|)")
    print("=" * 70)
    
    # Статистика и интерпретация
    print("\n" + "=" * 70)
    print("СТАТИСТИКА И ИНТЕРПРЕТАЦИЯ:")
    print("=" * 70)
    print(f"Всего пар для анализа: {n-1 if n>1 else 0}")
    print("")
    print("Интерпретация результатов:")
    print("- Большое значение в (а) указывает на кластеризацию положительных чисел.")
    print("- Большое значение в (б) указывает на частую смену знака.")
    print("- Большое значение в (в) указывает на то, что последовательность")
    print("  часто уменьшается по модулю при сохранении знака.")
    print("=" * 70)


if __name__ == "__main__":
    main()
    input("\n\nНажмите Enter, чтобы завершить программу.")
