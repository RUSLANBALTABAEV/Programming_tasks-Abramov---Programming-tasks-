"""
ГЛАВА 1
ОСНОВНЫЕ ПРИЁМЫ ПРОГРАММИРОВАНИЯ
9. Вычисления с хранением последовательности значений

303. Даны действительные числа x1,…, x200, принадлежащие интервалу (0, 1]. Полуинтервал разбивается на 100 равных частей.
Вычислить p1, …, p100, где pk = mk/2000, а mk – количество заданных чисел, принадлежащих полуинтервалу (0.01(k – 1), 0.01k] (k = 1, …,100).
"""


import random

def main():
    print("Программа вычисляет p_k = m_k / 2000 для 200 чисел из интервала (0,1].")
    print("Интервал разбит на 100 равных частей: (0.01*(k-1), 0.01*k] для k=1..100.")
    
    # Выбор способа ввода
    print("\nВыберите способ задания последовательности:")
    print("1. Ввести числа вручную (через пробел)")
    print("2. Сгенерировать случайные числа")
    print("3. Использовать готовый равномерный набор")
    
    while True:
        try:
            choice = int(input("\nВаш выбор (1-3): "))
            if 1 <= choice <= 3:
                break
            else:
                print("Ошибка: введите 1, 2 или 3.")
        except ValueError:
            print("Ошибка: введите целое число.")
    
    n = 200  # количество чисел
    
    if choice == 1:
        # Ручной ввод
        print(f"\nВведите {n} действительных чисел из интервала (0,1] через пробел:")
        while True:
            try:
                line = input().strip()
                numbers = list(map(float, line.split()))
                if len(numbers) != n:
                    print(f"Ошибка: нужно ровно {n} чисел. Попробуйте снова.")
                    continue
                # Проверка, что все числа в (0,1]
                valid = all(0 < x <= 1 for x in numbers)
                if not valid:
                    print("Ошибка: числа должны принадлежать интервалу (0,1].")
                    continue
                break
            except ValueError:
                print("Ошибка: введите числа корректно.")
        x = numbers
    
    elif choice == 2:
        # Случайные числа
        random.seed()
        x = []
        for _ in range(n):
            # random.uniform(0,1) дает число в [0,1], может быть 0, но редко
            val = random.uniform(0, 1)
            # Исключаем 0 (заменяем на маленькое положительное)
            if val == 0:
                val = 1e-10
            x.append(val)
        print("\nСгенерировано 200 случайных чисел.")
    
    else:
        # Готовый набор: равномерно распределенные от 0.005 до 0.995 с шагом
        # Просто создадим 200 чисел, например, линейно от 0.001 до 0.999
        x = [ (i+1)/201 for i in range(n) ]  # примерно от 0.004975 до 0.995
        print("\nИспользуется равномерный набор чисел.")

    # Подсчет m_k
    m = [0] * 100
    for val in x:
        # Определяем номер интервала k (от 1 до 100)
        # val в (0,1]. Интервал k: (0.01*(k-1), 0.01*k]
        # Используем формулу: k = ceil(val * 100) ? Например, val=0.005 -> 0.5*100=0.5 -> ceil=1? Но надо учесть границы.
        # Если val = 0.01, то должно попасть в интервал 1? (0,0.01] включает 0.01, значит k=1.
        # Для val=0.01, val*100 = 1.0, ceil(1.0)=1, хорошо.
        # Для val=0.001, val*100=0.1, ceil=1.
        # Для val=0.99, val*100=99, ceil=99, интервал (0.98,0.99]? Нет, (0.98,0.99] это k=99? По формуле: 0.99*100=99, ceil=99, правильно.
        # Для val=1.0, val*100=100, ceil=100, интервал (0.99,1] включает 1, k=100.
        # Но осторожно: val может быть ровно 0? Не должно, но если 0, то val*100=0, ceil=0 - не подходит. У нас val>0.
        k = int(val * 100)
        # Но если val точно равно 0.01*k, то val*100 = k, но из-за погрешностей может получиться k-1. Используем ceil?
        # Лучше использовать формулу: k = int(val * 100) + 1? Рассмотрим:
        # val=0.01: val*100=1.0, int=1, тогда k=1? Если int+1=2 - неверно.
        # val=0.0099: val*100=0.99, int=0, тогда k=1 - верно.
        # Значит, нужно брать int(val*100) и если val*100 не целое, то прибавлять 1? Но это сложно.
        # Проще: k = math.ceil(val * 100)  для val>0. Но для val=0.01 ceil=1, хорошо. Для val=0.0099 ceil=1, хорошо. Для val=0.99 ceil=99, хорошо. Для val=1 ceil=100.
        # Однако для val=0.001 ceil=1, верно.
        # Используем math.ceil
        import math
        k = math.ceil(val * 100)
        # Проверка границ: val*100 может быть ровно 0? нет. val>0.
        if k < 1:
            k = 1
        if k > 100:
            k = 100
        m[k-1] += 1

    # Вычисляем p_k
    p = [count / 2000 for count in m]

    # Вывод результатов
    print("\n" + "="*60)
    print("Результаты:")
    print("Интервал k | Границы             | m_k | p_k")
    print("-" * 60)
    
    # Для компактности выведем первые 10, последние 10 и несколько с ненулевыми
    # Можно вывести все, но это много. Сделаем выборку.
    # Выведем все интервалы, где m_k > 0, и первые 5 и последние 5.
    nonzero = [(i, m[i], p[i]) for i in range(100) if m[i] > 0]
    print(f"Всего интервалов с ненулевыми значениями: {len(nonzero)}")
    print("\nПервые 10 интервалов:")
    for i in range(10):
        left = 0.01 * i
        right = 0.01 * (i+1)
        print(f"{i+1:3} | ({left:.3f}, {right:.3f}] | {m[i]:3} | {p[i]:.6f}")
    
    print("\nПоследние 10 интервалов:")
    for i in range(90, 100):
        left = 0.01 * i
        right = 0.01 * (i+1)
        print(f"{i+1:3} | ({left:.3f}, {right:.3f}] | {m[i]:3} | {p[i]:.6f}")
    
    # Проверка суммы
    total_m = sum(m)
    total_p = sum(p)
    print(f"\nСумма m_k = {total_m} (должно быть 200)")
    print(f"Сумма p_k = {total_p:.6f} (должно быть 0.1)")

if __name__ == "__main__":
    main()
    input("\nНажмите Enter, чтобы завершить программу.")
