"""
ГЛАВА 1
ОСНОВНЫЕ ПРИЁМЫ ПРОГРАММИРОВАНИЯ
9. Вычисления с хранением последовательности значений

307. Даны натуральные числа x1, y1, x2, y2, …, xn, yn. Числа xi, yi являются координатами точек. Построить на экране точки, заданные последовательностью x1, y1, x2, y2, …, xn, yn. Точки должны строиться поочередно: построение каждой последующей точки должно сопровождаться удалением предыдущей. Процесс построения следует выполнять дважды: первый раз начиная точкой с номером 1 и кончая точкой с номером n, второй раз – в обратном порядке – начиная точкой с номером n и заканчивая точкой с номером 1.
"""


import turtle
import random
import time

def main():
    print("Программа для поочередного построения и удаления точек на экране.")
    print("Точки задаются парами координат (x, y).")
    print("Сначала они появляются по порядку от 1 до n, каждая следующая появляется после удаления предыдущей.")
    print("Затем процесс повторяется в обратном порядке от n до 1.")
    
    # Выбор способа ввода
    print("\nВыберите способ задания точек:")
    print("1. Ввести координаты вручную")
    print("2. Сгенерировать случайные точки")
    print("3. Использовать готовый пример")
    
    while True:
        try:
            choice = int(input("\nВаш выбор (1-3): "))
            if 1 <= choice <= 3:
                break
            else:
                print("Ошибка: введите 1, 2 или 3.")
        except ValueError:
            print("Ошибка: введите целое число.")
    
    if choice == 1:
        # Ручной ввод
        while True:
            try:
                n = int(input("Введите количество точек n: "))
                if n > 0:
                    break
                else:
                    print("Ошибка: n должно быть положительным.")
            except ValueError:
                print("Ошибка: введите целое число.")
        
        points = []
        print("Введите координаты x y (целые числа) через пробел для каждой точки:")
        for i in range(n):
            while True:
                try:
                    coords = input(f"Точка {i+1}: ").split()
                    if len(coords) != 2:
                        print("Ошибка: введите два числа.")
                        continue
                    x = int(coords[0])
                    y = int(coords[1])
                    points.append((x, y))
                    break
                except ValueError:
                    print("Ошибка: введите целые числа.")
    
    elif choice == 2:
        # Случайные точки
        n = random.randint(5, 15)
        points = []
        for _ in range(n):
            x = random.randint(-200, 200)
            y = random.randint(-200, 200)
            points.append((x, y))
        print(f"Сгенерировано {n} случайных точек.")
    
    else:
        # Готовые примеры
        examples = [
            [(50, 50), (100, 100), (150, 50), (200, 150), (250, 100)],
            [(-100, -100), (-50, -50), (0, 0), (50, 50), (100, 100)],
            [(30, 120), (80, 80), (130, 180), (180, 60), (230, 140), (280, 200)]
        ]
        print("Выберите готовый набор:")
        for idx, ex in enumerate(examples, 1):
            print(f"{idx}. {ex}")
        while True:
            try:
                ex_choice = int(input("Ваш выбор (1-3): "))
                if 1 <= ex_choice <= 3:
                    points = examples[ex_choice-1]
                    n = len(points)
                    break
                else:
                    print("Ошибка: введите 1-3.")
            except ValueError:
                print("Ошибка: введите целое число.")
    
    # Настройка экрана turtle
    screen = turtle.Screen()
    screen.setup(width=800, height=600)
    screen.bgcolor("white")
    screen.title("Поочередное построение и удаление точек")
    screen.tracer(0)  # отключаем автоматическое обновление для плавности
    
    # Создаем черепаху
    t = turtle.Turtle()
    t.speed(0)
    t.hideturtle()
    t.penup()
    
    # Параметры точек
    dot_size = 10
    point_color = "blue"
    bg_color = "white"
    
    def draw_point(x, y, color=point_color):
        t.goto(x, y)
        t.dot(dot_size, color)
        screen.update()
    
    def erase_point(x, y):
        t.goto(x, y)
        t.dot(dot_size, bg_color)
        screen.update()
    
    # Функция для одного прохода (последовательность индексов)
    def animate_sequence(indices):
        for idx in indices:
            x, y = points[idx]
            draw_point(x, y)
            time.sleep(0.5)
            if idx != indices[-1]:  # не последний элемент? Но по условию надо удалить перед следующим.
                # В этом проходе мы удаляем точку перед показом следующей, но после паузы.
                # Однако для первого элемента мы просто показываем, потом удаляем перед вторым.
                # Но если мы хотим, чтобы после последней она осталась? В условии: "построение каждой последующей точки должно сопровождаться удалением предыдущей". То есть после последней она не удаляется? Но затем второй проход начинается с последней? Во втором проходе мы начинаем с последней, и затем удаляем её перед показом предпоследней и т.д.
                # Значит, в первом проходе после показа последней точки она остается, потом начинается второй проход с показа последней (она уже есть? но мы должны её показать снова? Наверное, лучше во втором проходе сначала показать последнюю (она уже есть), но чтобы было наглядно, можно стереть и снова показать? Или просто начать с неё. Поскольку она уже видна, можно не рисовать повторно. Но тогда процесс удаления начнется со следующей? Давайте сделаем так: в первом проходе после показа последней она остается. Во втором проходе мы начинаем с последней (она уже есть), но по логике нам нужно показать её? Но она уже есть, поэтому можно просто сделать паузу, а затем удалить её и показать предпоследнюю. Но тогда предпоследняя появится после удаления последней. Это соответствует условию: второй проход начинается с точки n (она уже видна), затем удаляем её и показываем n-1 и т.д. Однако тогда точка n будет видна дважды? Но это нормально.
                # Упростим: в каждом проходе мы будем показывать точку (даже если она уже есть) и затем удалять перед следующей. Для первого прохода: показываем 1, ждем, удаляем 1, показываем 2, ждем, удаляем 2, ... показываем n (не удаляем). Для второго прохода: показываем n (она уже есть, но мы можем повторно нарисовать — это не повредит), ждем, удаляем n, показываем n-1, ждем, удаляем n-1, ... показываем 1 (не удаляем). В итоге после второго прохода останется точка 1.
                # Это соответствует условию: "построение каждой последующей точки должно сопровождаться удалением предыдущей". То есть при переходе к следующей предыдущая удаляется.
                erase_point(x, y)
    
    # Первый проход: от 0 до n-1 (номера 1..n)
    print("\nПервый проход (от 1 до n):")
    animate_sequence(range(n))
    
    # Небольшая пауза между проходами
    time.sleep(1)
    
    # Второй проход: от n-1 до 0 (номера n..1)
    print("Второй проход (от n до 1):")
    animate_sequence(range(n-1, -1, -1))
    
    print("Процесс завершен. Нажмите на окне для выхода.")
    screen.exitonclick()

if __name__ == "__main__":
    main()
